//						.__..  . __ 
//						[__]|\/|/  `
//						|  ||  |\__.
//
// The Advanced MUD Codebase Project
// AMC, copyright (c) 2005, 2006 by Owen Varley <owen@sw-erp.org>

//
// Interpreted by Owen Varley [Nekekami] :: <owen#sw-erp.org>
// Lead Design :: Ken Rune Mikkelson [N'kEnNy], Charlie Van Der Born [Chaz]
// Designed by the SW-ERP Development Team [www.sw-erp.org]
//
// Durham   :: SE Project 2005/2006
// Started  :: 29 May 2005
// Based on :: Mudcore, copyright (c) 2000, 2001 by Gary McNickle <gary#mcnickle.org>

// Class    :: CGameWorld
// Header   :: GameWorld.h
// Function :: The MUD consists of a series of worlds, each of which contains a number of Areas.
//			:: There must be at least one GameWorld for the mud to run. GameWorlds handle all of 
//			:: their own updates and manage all of their own Actors and Players. Also, each GameWorld
//			:: contains a Navigation object for pathfinding through that world. Note that this code 
//			:: provides the basic elements to support multiple game worlds, yet this implementation
//			:: only includes a 'base' or default gameworld that has been made global.
//

#pragma warning(disable: 4786)

#include <map>
#include <list>
#include <vector>
#include <fstream>

#include "MudCore.h"
#include "GameObjects.h"
#include "GameWorld.h"
#include "Command.h"
#include "Emotions.h"
#include "Spatial.h"
#include "Space.h"
#include "CmdsComm.h"
#include "CmdsMove.h"
#include "CmdsPlayer.h"
#include "CmdsStaff.h"
#include "CmdsInfo.h"
#include "Pathfinding.h"
#include "Area.h"
#include "Room.h"
#include "Npc.h"
#include "Actor.h"
#include "User.h"
#include "Player.h"
#include "Socket.h"
#include "Placement.h"
#include "Item.h"
#include "Tools.h"
#include "Timer.h"
#include "OTools.h"
#include "../gTools/Log.h"

UINT uiUniqueWorldID = 0;

char* CGameWorld::nProgress[] = { "#200", "#200", "#201", "#201", "#500", "#500", "#100", "#100", "#101", "#101" };

CGameWorld::CGameWorld()
{
	m_iRunningTotal = 0;
	m_ID = uiUniqueWorldID++;

	m_Players.clear();
	m_Mobiles.clear();
	m_Items.clear();
	m_Areas.clear();
	m_CmdParsers.clear();
	m_pNavigator = new CNavigator(this);
}

CGameWorld::~CGameWorld()
{
	m_Mobiles.clear();
	m_Players.clear();
	m_Items.clear();
	m_Areas.clear();
	m_CmdParsers.clear();
	
	delete m_pNavigator;
	m_pNavigator = NULL;
}

bool CGameWorld::Initialize()
{
	LOG_SCOPE("CGameWorld::Initialize");

	g_Log.Log(LOG_INFO, "Initializing Gameworld '%s'...", Name());

	if ( !LoadCommands() || !LoadEmotions() || !LoadModules() || !LoadHullCubes())
	{
		g_Log.Log(LOG_ERROR, "'%s' failed to initialize.", Name());
		return false;
	}

	g_Log.Log(LOG_INFO, "'%s' Initialized.", Name());
	return true;
}

void CGameWorld::SaveAll()
{
	ActorMap::iterator ActorItor;
	AreaList::iterator AreaItor;

	// Save all Players
	for (ActorItor = m_Players.begin(); ActorItor != m_Players.end(); ActorItor++)
	  ((*ActorItor).second)->Save();

	// Save all NPCs
	for (ActorItor = m_Mobiles.begin(); ActorItor != m_Mobiles.end(); ActorItor++)
	  ((*ActorItor).second)->Save();

	// Save all Items
	for (ActorItor = m_Items.begin(); ActorItor != m_Items.end(); ActorItor++)
	  ((*ActorItor).second)->Save();

	// Save all Areas
	for (AreaItor = m_Areas.begin(); AreaItor != m_Areas.end(); AreaItor++)
		((*AreaItor))->Save();

	// Save the Area List
	SaveAreas();
}


bool CGameWorld::SaveAreas()
{
	gString gsAreaFile;
	CGameObjects& globals = CGameObjects::Get();
	std::fstream fp;


	gsAreaFile.Format("%s%s\\arealist.dat", CGameObjects::Get().m_Config.szDir[CGameObjects::_WORLD], this->Key());

	fp.open(gsAreaFile, ios::out);

	if ( !fp.is_open() )
		return false;

	CTools& Tools = *CGameObjects::Get().Tools();
	
	Tools.WriteLn(fp, "// %s Area List - Generated by AMC", this->m_gsName);
	for (AreaList::iterator area = this->Areas().begin(); area != this->Areas().end(); area++)
	{
		// Dont save any area files for Templates
		if ((*area)->Ship() == "Template")
			continue;

		Tools.WriteLn(fp, "%s", (*area)->m_gsFileName);
	}
		
	fp.close();

	return true;

}

// Added 7/1/2006 to allow an Area to be deleted from a GameWorld
// [1] Removes Area from Arealist file
// [2] Remove Area file from Server
// [3] Move all Players contained in Area to DefaultArea
void CGameWorld::DeleteArea(CArea *pArea)
{
	LOG_SCOPE("CGameWorld::DeleteArea");

	CArea* pDelete = NULL;

	// Check the area exist
	if (!pArea)
		return;

	// [1] Remove the Area from the Arealist

	// Iterator through the entire list so we can find the index value for the area we wish to delete
	for (AreaList::iterator area = this->Areas().begin(); area != this->Areas().end(); area++)
	{
		if ((*area)->Name() == pArea->Name())
		{
			// Found the area to delete
			pDelete = *area;
			this->Areas().erase(area);
			break;
		}
	}

	// End [1]

	// [2] Remove Area file from Server
	gString gsFile;
    gsFile.Format("%s%s\\Areas\\%s", CGameObjects::Get().m_Config.szDir[CGameObjects::_WORLD], this->Key(), pArea->FileName());
	unlink(gsFile);
	// End [2]

	// [3] Remove Players from Area
	for (ActorMap::iterator act = this->Players().begin(); act != this->Players().end(); act++)
	{
		// If they are in this Area we need to move them to the Default area
		if (((*act).second)->CurrentRoom()->Area() == pArea->Area())
		{
			CArea* pArea = this->GetArea(CGameObjects::Get().ConfigData().GetInt("default_area", "Options"));
			((*act).second)->Write("Occupying Area deleted, moving to default room.\n\r");
			((*act).second)->SetCurrentRoom((*pArea->Rooms()->begin()).second);
		}
	}
	// End [3]

	// [4] Free the memory
	delete pDelete;
	pDelete = NULL;

	this->SaveAreas();
	
}

CActor* CGameWorld::GetActor(gString gsName)
{
	ActorMap::iterator itor;
	gString gsActor;
	CActor* pActor = NULL;

	for (itor = m_Players.begin(); itor != m_Players.end(); itor++)
	{
		pActor = (*itor).second;
		gsActor = pActor->Name();

		gsName.MakeLower();
		gsActor.MakeLower();

		if ( gsActor.Find(gsName) >= 0 )
			return (*itor).second;
	}

	for (itor = m_Mobiles.begin(); itor != m_Mobiles.end(); itor++)
	{
		pActor = (*itor).second;
		gsActor = pActor->Name();

		gsName.MakeLower();
		gsActor.MakeLower();

		if ( gsActor.Find(gsName) >= 0 )
			return (*itor).second;
	}

	for (itor = m_Items.begin(); itor != m_Items.end(); itor++)
	{
		pActor = (*itor).second;
		gsName = pActor->Name();

		gsName.MakeLower();
		gsActor.MakeLower();

		if ( gsActor.Find(gsName) >= 0 )
			return (*itor).second;
	}

	return NULL;
}


void CGameWorld::Describe(CActor* pA, CPlacement v, bool bDescription)
{
	CArea* pArea = NULL;
	CRoom* pRoom = NULL;

	if (pA->CurrentRoom()->GetParent() != NULL)
		pA->HomeWorld()->Describe( pA, pA->CurrentRoom()->GetParent(), bDescription );

	if ( (pArea = GetArea(v)) != NULL )
	{
		if ( (pRoom = pArea->GetRoom(v.Room())) != NULL )
		{
			bool bExit = false;
			ExitList::iterator ExitItor;
			ActorMap::iterator ActorItor;
			CExit* pExit = NULL;
			CActor* pActor = NULL;
			CActor* Ch = pA;
			gString gsComponents;

			if (pRoom->Components().size() > 0)
				gsComponents = " #400>#401>#701 ";

			int nCount = 0;
			for (gStringList::iterator comp = pRoom->Components().begin(); comp != pRoom->Components().end(); comp++)
			{
				if (nCount % 2 == 0)
					gsComponents += "#700" + *comp + " ";
				else
					gsComponents += "#701" + *comp + " #700";

				nCount++;
			}

					
			// Show name, components and description
			pA->Write("\n\r%s\n\r%s\n\r%s#700\n\r\n\r", pRoom->Name(), gsComponents, pRoom->FormatDesc(pRoom->Description(pA)));

			// Show any ships that have landed here
			if (Ch->CurrentRoom()->Ships().size() > 0)
			{
				int nCounter = 1;
				Ch->Write("\n\r");

				std::vector<gStringList::iterator> DeleteList;

				for (gStringList::iterator shi = Ch->CurrentRoom()->Ships().begin(); shi != Ch->CurrentRoom()->Ships().end(); shi++)
				{
					CGalaxy* pGalaxy = CGameObjects::Get().GameWorld()->Galaxy();

					gString gsTemp = *shi;

					CShip * pShip =  pGalaxy->GetShi(*shi);

					if (!pShip)
					{
						DeleteList.push_back(shi);
						continue;
					}

					if (nCounter % 2 == 0)
						Ch->Write("#600%-40s#700  ", pShip->m_gsType);
					else
						Ch->Write("#601%-40s#700  ", pShip->m_gsType);

					if (nCounter % 2 == 0)
						Ch->Write("\n\r");

					nCounter++;
				}

				for (std::vector<gStringList::iterator>::iterator it = DeleteList.begin(); it != DeleteList.end(); it++)
					Ch->CurrentRoom()->Ships().erase(*it);


				Ch->Write("#700\n\r");

			}

			// Show each exit
			/*
			if ( (int)pRoom->Exits().size() > 0 )
			{
				bExit = true;
				pA->Write("[ ");
				for (ExitItor = pRoom->Exits().begin(); ExitItor != pRoom->Exits().end(); ExitItor++)
				{
					pExit = (CExit*)(*ExitItor);
					if ( pExit )
						pA->Write("%s ", pExit->DirectionStr());
				}
				pA->Write("]\n\r");
			}
			else // Added to display None if they are no exits in the room
			{
				pA->Write("[ None ]\n\r");
			} */

			// Show each Player/Mobile/Item to the player
			for (ActorItor=pRoom->m_Actors.begin(); ActorItor != pRoom->m_Actors.end(); ActorItor++)
			{
				pActor = (CActor*)((*ActorItor).second);
				if (pActor)
				{
					if (pA == pActor)
						continue;

					pA->Write("%s %s\n\r",
								pActor->Name(),
								pActor->Vnum() > -1 ? pActor->ShortDesc() :  pActor->Title());
				}
			}

			// If they are in a control point show them space if launched and the room they are landed in otherwise
			if (Ch->CurrentRoom()->GetComp(CComponent::CT_CONTROLPOINT)->size() > 0)
			{
				int nVisualRange = CGameObjects::Get().ConfigData().GetInt("visual_range", "Options");
				CShip * pShip = Ch->CurrentRoom()->GetShip();

				if (pShip->m_ShipState->IsSet(CShip::_LANDED))
				{
					Ch->Write("Through the ship's viewport you can see:\n\r");

					// Now we show them the room outside
					CArea* pLandArea = NULL;
					CRoom* pLandRoom = NULL;

					if ( (pLandArea = GetArea(pShip->m_Land)) == NULL )
						return;

					if ( (pLandRoom = pLandArea->GetRoom(pShip->m_Land.Room())) == NULL )
						return;

					// Show the room name and description to the player
					pA->Write("\n\r%s\n\r%s\n\r\n\r", pLandRoom->Name(), pLandRoom->Description(pA));

					// Show each exit
					/*
					if ( (int)pRoom->Exits().size() > 0 )
					{
						bExit = true;
						pA->Write("[ ");
						for (ExitItor = pLandRoom->Exits().begin(); ExitItor != pLandRoom->Exits().end(); ExitItor++)
						{
							pExit = (CExit*)(*ExitItor);
							if ( pExit )
								pA->Write("%s ", pExit->DirectionStr());
						}
						pA->Write("]\n\r");
					}
					else // Added to display None if they are no exits in the room
					{
						pA->Write("[ None ]\n\r");
					}*/

					// Show each Player/Mobile/Item to the player
					for (ActorItor=pLandRoom->m_Actors.begin(); ActorItor != pLandRoom->m_Actors.end(); ActorItor++)
					{
						pActor = (CActor*)((*ActorItor).second);
						if (pActor)
						{
							if (pA == pActor)
								continue;

							pA->Write("%s %s\n\r",
										pActor->Name(),
										pActor->Vnum() > -1 ? pActor->ShortDesc() :  pActor->Title());
						}
					}
					return;
				}
				else
					Ch->Write("Against the hard background of space you can see:\n\r");
				// When you look you will only see contacts that are within your visual range
				// which is defined within the Config file. You can see the ship type of any
				// vessel within visual_range, visual markings within 1/2 of visual_range and
				// vague size within 2 X visual_range
				CGalaxy* pGalaxy = CGameObjects::Get().GameWorld()->Galaxy();

				SpatialMap::iterator find = pGalaxy->m_SpatialMap.find(pShip->m_gsSector);

				std::vector<SpatialList::iterator>DeleteList;

				for (SpatialList::iterator spa = (*find).second.begin(); spa != (*find).second.end(); spa++)
				{
					CSpatial* pSpatial = ***spa;

					// If the object no longer exists we delete it from the list
					if (!pSpatial)
					{
						DeleteList.push_back(spa);
						continue;
					}

					// Work out the distance
					long double nDistance = pSpatial->m_Location->Distance(pShip->m_Location);

					// Out of visual range (this check is only for space craft)
					#pragma message(Reminder "CmdLook >> Need to add in PER Roll here")
					if (nDistance > (2 * nVisualRange) && pSpatial->m_nType == CSpatial::SO_SHIP)
						continue;

					// We don't want to see ourselves
					if (pSpatial->m_gfFileName == pShip->m_gfFileName)
						continue;

					// Through our validation now lets output the ships
					if (pSpatial->m_nType == CSpatial::SO_SHIP)
					{
						CShip* pShip = (CShip*)pSpatial;

						if (nDistance < (2 * nVisualRange) && nDistance > nVisualRange)					
							Ch->Write("#600The vague outline of a %s sized vessel.#700\n\r", CShip::szTypes[pShip->m_nType]);							
						else if (nDistance < nVisualRange && nDistance > (0.5 * nVisualRange))
							Ch->Write("#600A %s class %s#700\n\r", pShip->m_gsType, CShip::szTypes[pShip->m_nType]);
						else if (nDistance < (0.5 * nVisualRange))
							Ch->Write("#600A %s class %s, designated %s#700\n\r", pShip->m_gsType, CShip::szTypes[pShip->m_nType], ((CShip*)pSpatial)->m_gsName);						
					}
					else
						Ch->Write("#601The %s, %s#700\n\r", CSpatial::szTypes[pSpatial->m_nType], pSpatial->m_gsName);
				}
			}

// Not required as now added to Interpreter! <- Nek 07/06/05
//			gString gsPrompt = pA->IsPlayer() ? ((CPlayer*)pA)->Prompt() : " $]";
//			pA->Write( "\n\r%s", gsPrompt );
		}
	}
}

// Show the parent room to a player
void CGameWorld::Describe(CActor* pA, CParentRoom * pR, bool bDescription)
{
	// First we write the parent room's description
	if (pA && pR)
	{
		pA->Write("%s#700\n\r", pR->Name());

		// We only show the room's description if they type look, or if they are moving
		// from one parent room to another
		if (bDescription)
			pA->Write("%s#700\n\r", pR->Description(pA));

		// Now we need to list all Actors that are within the parent room
		// based on the Actor's perception
		if (pR->Actors().size() <= 0)
			return;

		// We have to created a reference to Actors as the Actors() function will
		// modify the list everytime it is called.
		ActorMap& amActors = pR->Actors();

		for (ActorMap::iterator act = amActors.begin(); act != amActors.end(); act++)
		{
			// Check how far away each actor is by building a pathfinding route to them
			CDirectionList dlList;

			// Build route
			Navigator()->BuildPathTo(dlList, pA, (*act).second);

			// Check how far they are, based on the number of rooms to travel
			int nDistance = dlList.Remaining();

			if (nDistance <= pA->Perception()+1)
			{
				// They are within visible range
		#pragma message (Reminder "[CGameWorld::Describe] Parent room needs to add Stealth check modifier")

				gString gsVerb;
				gString gsPrefix;
				
				// Work out how far away they are
				switch (nDistance)
				{
					// If they are in the same room, we dont bother showing them
					case 0: continue;
						break;

					case 1: gsVerb = "just";
						gsPrefix = "*";
						break;

					case 2: gsVerb = "very near";
						gsPrefix = "**";
						break;

					case 3: gsVerb = "near";
						gsPrefix = "***";
						break;

					case 4: gsVerb = "far";
						gsPrefix = "****";
						break;

					case 5: gsVerb = "very far";
						gsPrefix = "*****";
						break;

					default: gsVerb = "miles";
						gsPrefix = "******";
						break;
				}

				// Output this information to the Actor
				pA->Write("#601%s#700 %s is %s %s\n\r", gsPrefix, (*act).second->Name(), gsVerb, CExit::szExitNames[dlList.Next()]);
				
			}
			else
			{
				continue;
			}		

		}
	}
}




void CGameWorld::Add(CActor *pA, CPlacement vTo)
{
	LOG_SCOPE("CGameWorld::Add");

	CArea* pArea = GetArea(vTo);
	CRoom* pRoom = pArea ? pArea->GetRoom(vTo) : NULL;

	pA->SetHomeWorld(this);

	if ( !pArea || !pRoom )
	{
		g_Log.Log(LOG_ERROR, "%s \"%s\" has an invalid position.",
									pA->IsNPC() ? "NPC" : pA->IsItem() ? "Item" : "Player",
									pA->Name());

		pRoom = pArea ? pArea->GetRoom( 1 ) : NULL;

		if ( !pRoom )
		{
			pA->Write("Invalid Position. Attempting to set to default.\n\r");
			pArea = GetArea(CGameObjects::Get().ConfigData().GetInt("default_area", "Options"));
			pRoom = pArea ? pArea->GetRoom(0) : NULL;

			if (!pArea || !pRoom)
			{
				pA->Write("Default setting failed. Email Administration.\n\r");
				if ( pA->IsPlayer() )
					((CPlayer*)pA)->User()->Socket()->Close();

				return; // #TODO# This is a bug, we cannot return as it just carries on, need to switch to bool
			}
		}
	}

	// Note: There can be any # of actors of the same VNUM in the world, so we have to
	// access them by their unique id.
	if ( pA->IsNPC() )
	{
		m_Mobiles.insert(ActorMap::value_type(pA->GUID(), static_cast<CNpc*>(pA)));
		pRoom->m_Actors.insert( ActorMap::value_type(pA->GUID(), pA));
	}
	else
	if ( pA->IsPlayer() )
	{
		m_Players.insert(ActorMap::value_type(pA->GUID(), static_cast<CPlayer*>(pA)));
		pRoom->m_Actors.insert( ActorMap::value_type(pA->GUID(), pA));
	}
	else
	if ( pA->IsItem() )
	{
		m_Items.insert(ActorMap::value_type(pA->GUID(), pA));
		pRoom->m_Items.push_back(static_cast<CItem*>(pA));
	}

	pRoom->m_Actors.insert( ActorMap::value_type(pA->GUID(), pA) );

	pA->SetCurrentRoom(pRoom);
	Describe(pA, pA->Position(), true );

	if ( (int)m_Players.size() > MaxPlayers() )
		MaxPlayers()++;
}

void CGameWorld::Remove(CActor *pA)
{
	CArea* pArea = NULL;
	CRoom* pRoom = NULL;

	// Remove from Room first.
	if ( (pArea = GetArea(pA->Position().Area())) != NULL )
	{
		if ( (pRoom = pArea->GetRoom(pA->Position().Room())) != NULL )
			pRoom->Remove(pA);
	}

	if ( pA->IsPlayer() )
		m_Players.erase( pA->GUID() );
	else
	if ( pA->IsNPC() )
		m_Mobiles.erase( pA->GUID() );
	else
	if ( pA->IsItem() )
		m_Items.erase( pA->GUID() );

}

CArea* CGameWorld::GetArea(CPlacement v)
{
	AreaList::iterator pos;
	CArea *pA = NULL;

	for (pos = m_Areas.begin(); pos != m_Areas.end(); pos++)
	{
		pA = (CArea*)(*pos);
		if ( pA->m_Position.Area() == v.Area() && pA->m_Position.World() == v.World() )
			return pA;
	}

	// Lazy coding goes here #TODO#:: LAZY CODING
	return NULL;
}

CArea* CGameWorld::GetArea(int iAreaNum)
{
	AreaList::iterator pos;
	CArea *pA = NULL;

	for (pos = m_Areas.begin(); pos != m_Areas.end(); pos++)
	{
		pA = (CArea*)(*pos);
		if ( pA->m_Position.Area() == iAreaNum )
			return pA;
	}
	return NULL;
}


void CGameWorld::MoveTo(CActor *pA, CPlacement v)
{
	CArea* pArea;
	CRoom* pFrom;
	CRoom* pTo;
	gString szMoveTo, szMoveFrom;
	ActorMap::iterator pos;

	// Are they moving to a new parent room?
	bool bNewparent = false;

	pArea = GetArea(pA->Position().Area());
	pFrom = pArea->GetRoom( pA->Position() );

	pArea = GetArea(v.Area());
	pTo = pArea->GetRoom(v);

	gString gsVerb = "walks";

	if (pA->ActorPositions()->IsSet(CActor::_PRONE))
		gsVerb = "crawls";
	else if (pA->ActorPositions()->IsSet(CActor::_STANDING))
		gsVerb = "walks";


	if ( pFrom )
	{
		pos = pFrom->m_Actors.find(pA->GUID());

		if ( pos != pFrom->m_Actors.end() )
		{
			szMoveTo = pFrom->FindDirection( v );
			szMoveFrom = pTo->FindDirection( pFrom->Position() );

			pFrom->Remove(pA);

			if ( szMoveTo != "" )
				pFrom->Write(CRoom::_LOCAL, "%s %s %s.\n\r", pA->Name(), gsVerb, szMoveTo );
			else
				pFrom->Write(CRoom::_LOCAL, "%s has exited the room.\n\r", pA->Name());

			// Handle message passing for the Parent Room
			// Two cases: 
			// >> 1 - Moving within the Parent room
			// >> 2 - Moving to a new Parent room	
			if ( pTo )
			{
				// Case 1
				if ( pTo->Parent() == pFrom->Parent() )
				{
					if (pTo->GetParent())
						pTo->GetParent()->Write(pA, "%s %s %s\n\r", pA->Name(), gsVerb, szMoveTo );
				}
				else
				// Case 2
				{
					CParentRoom* pParentFrom = pFrom->GetParent();
					CParentRoom* pParentTo   = pTo->GetParent();

					if (pParentFrom)
						pParentFrom->Write(pA, "%s leaves the area, heading %s\n\r", pA->Name(), szMoveTo);

					if (pParentTo)
						pParentTo->Write(pA, "%s arrives from the %s\n\r", pA->Name(), szMoveFrom);
				}

			}

		}
	}

	if ( pTo )
	{
		if ( szMoveFrom != "" )
			pTo->Write(CRoom::_LOCAL, "%s %s into the room from the %s.\n\r", pA->Name(), gsVerb, szMoveFrom );
		else
			pTo->Write(CRoom::_LOCAL, "%s has entered the room.\n\r", pA->Name() );

		pTo->Add(pA);
		pA->SetCurrentRoom(pTo);
		Describe(pA, pA->Position(), bNewparent );
	}
}

void CGameWorld::MoveTo(CItem *pI, CPlacement v)
{
	CArea* pArea = NULL;
	CRoom* pFrom = NULL;
	CRoom* pTo   = NULL;

	pArea = GetArea(pI->Position().Area());
	pFrom = pArea->GetRoom( pI->Position() );

	pArea = GetArea(v.Area());
	pTo = pArea->GetRoom( v );

	if ( pFrom )
		pFrom->Remove(pI);

	if ( pTo )
	{
		pTo->Add(pI);
		pI->SetCurrentRoom(pTo);

		Describe(pI, pI->Position(), false );
	}
}

int CGameWorld::Write(char *fmt, ...)
{
	char buf[MSL];
	va_list args;
	int nWrite = 0;
	int length = 0;

	va_start (args, fmt);
	length = _vsnprintf(buf, MSL, fmt, args);
	va_end (args);

	for (ActorMap::iterator pos = m_Players.begin(); pos != m_Players.end(); pos++)
	{
		try 
		{
			if ((*pos).second != NULL )
				(*pos).second->Write(buf);
			
		}
		catch (...) {break;}
	}
	

	return 0;

}

void CGameWorld::Update(bool bForce)
{
	LOG_SCOPE("CGameWorld::Update");

	CGameObjects& globals = CGameObjects::Get();
	AreaList::iterator AreaItor;
	ActorMap::iterator ActorItor;
	PositionMap::iterator PositionItor;
	CrewList::iterator CrewItor;
	std::vector<CSpatial*> SpatialDelete;
	AreaList AreaDelete;
	
	static CProfile* pAU = globals.m_ProfileMgr.Find("area_updates");
	static CProfile* pPU = globals.m_ProfileMgr.Find("player_updates");
	static CProfile* pMU = globals.m_ProfileMgr.Find("npc_updates");
	static CProfile* pIU = globals.m_ProfileMgr.Find("item_updates");
	static CProfile* pWU = globals.m_ProfileMgr.Find("world_updates");
	static CProfile* pSU = globals.m_ProfileMgr.Find("space_updates");	// Added for space
	static CProfile* pCU = globals.m_ProfileMgr.Find("crew_updates");

	assert((pAU && pPU && pMU && pIU && pWU && pSU && pCU) && "Someone lost my profiles!");

	pWU->Start();

	pAU->Start();
	/////////////////////////////////////////////////////////////////////////////////
	// AREA UPDATES: We don't want to have to play around with iterators and the   //
	// undefined behaviour problems faced when deleting from within the list hence //
	// we add objects to delete to a delete list which is iterated through after   //
	// we have updated all other areas.                                            //
	/////////////////////////////////////////////////////////////////////////////////
	for (AreaItor = m_Areas.begin(); AreaItor != m_Areas.end(); AreaItor++)
	{
		CArea* pArea = (*AreaItor);

		try
		{
			if (pArea->m_bDelete)
			{
				AreaDelete.push_back(pArea);
				continue;
			}

			(*AreaItor)->Update(bForce);
		}
		catch (...) 
		{
			g_Log.Log(LOG_ERROR,"[CGameWorld::Update] An error occured while executing ::Update for Area <%s>.\n", (*AreaItor)->Name());
			continue;
		}
	}
	// Delete list
	for (AreaList::iterator dela = AreaDelete.begin(); dela != AreaDelete.end(); dela++)
		this->DeleteArea(*dela); // Frees the memory and removes Area from list

	AreaDelete.clear();
	pAU->Stop();

	pPU->Start();
	for (ActorItor = m_Players.begin(); ActorItor != m_Players.end(); ActorItor++)
	{
		try
		{
			((*ActorItor).second)->Update(bForce);
		}
		catch (...) 
		{
			g_Log.Log(LOG_ERROR,"[CGameWorld::Update] An error occured while executing ::Update for Player <%s>.\n", ((*ActorItor).second)->Name());
			continue;
		}
	}
	pPU->Stop();

	pMU->Start();
	for (ActorItor = m_Mobiles.begin(); ActorItor != m_Mobiles.end(); ActorItor++)
	{
		CNpc* pNpc = (CNpc*)((*ActorItor).second);
		try
		{
			pNpc->Update(bForce);
		}
		catch (...) 
		{
			g_Log.Log(LOG_ERROR,"[CGameWorld::Update] An error occured while executing ::Update for Mob <%s>.\n", ((*ActorItor).second)->Name());
			continue;
		}
	}
	pMU->Stop();

	pIU->Start();
	for (ActorItor = m_Items.begin(); ActorItor != m_Items.end(); ActorItor++)
	{
		try
		{
			((*ActorItor).second)->Update(bForce);
		}
		catch (...) 
		{
			g_Log.Log(LOG_ERROR,"[CGameWorld::Update] An error occured while executing ::Update for Object <%s>.\n", ((*ActorItor).second)->Name());
			continue;
		}
	}
	pIU->Stop();

	pSU->Start();
	/////////////////////////////////////////////////////////////////////////////////
	// SPATIAL UPDATES: As with Areas we need to use a delete list to free memory  //
	// and to handle objects that are to be deleted. The delete list is iterated   //
	// through after updates have been carried out. Objects to be deleted are not  //
	// Updated.																	   //
	/////////////////////////////////////////////////////////////////////////////////
	for (gSpatialMap::iterator pos = this->m_Galaxy.m_gSpatialMap.begin(); pos != this->m_Galaxy.m_gSpatialMap.end(); pos++)	
	{
		CSpatial* pSpatial = NULL;

		float fThisUpdate = CGameObjects::Get().Clock();
		try
		{				
			 pSpatial = (*pos).second;

			// If we are to delete this object then we can bypass the delay on the update
			if (pSpatial->m_bDelete)
			{
				SpatialDelete.push_back(pSpatial);
				continue;
			}

			// Only update every Spatial tick or if forced
			if ( fThisUpdate - pSpatial->m_fLastUpdate >= fSpaceUpdateDelta )
			{
				pSpatial->m_fLastUpdate = fThisUpdate;
				pSpatial->Update();
			}
				
		}
		catch (...)
		{
			g_Log.Log(LOG_ERROR,"[CGameWorld::Update] An error occured while executing ::Update for Spatial <%s>.\n", pSpatial->m_gsName);
			continue;
		}
	}
	for (std::vector<CSpatial*>::iterator dels = SpatialDelete.begin(); dels != SpatialDelete.end(); dels++)
		this->m_Galaxy.RemoveSpatial(*dels);

	SpatialDelete.clear();
	pSU->Stop();

	pCU->Start();
	for (CrewItor = m_CLoader.m_Crews.begin(); CrewItor != m_CLoader.m_Crews.end(); CrewItor++)
	{
		float fThisUpdate = CGameObjects::Get().Clock();
		try
		{
			if (fThisUpdate - (*CrewItor)->m_fLastUpdate >= fCrewUpdateDelta )
			{
				(*CrewItor)->m_fLastUpdate = fThisUpdate;
				(*CrewItor)->Update();
			}
		}
		catch (...)
		{
			g_Log.Log(LOG_ERROR, "An error occured while executing Update for Crew <%s>.\n", (*CrewItor)->m_gsName);
			continue;
		}
	}
	pCU->Stop();

	pWU->Stop();
}

bool CGameWorld::LoadCommands()
{
	LOG_SCOPE("CGameWorld::LoadCommands");
	gFileName	gsCmdFile;
	CCmdParser* pParser = new CCmdParser;
	bool		bRet = true;

	g_Log.Log(LOG_INFO, "Loading Commands...");

	gsCmdFile.Format("%sCrewCmds.dat", m_gsAreaListFile.AbsolutePath());
	CCmdParser* pCParser = new CCmdParser;

	if (pCParser->Init(gsCmdFile))
	  m_CmdParsers.push_back( pCParser );
	else
	{
		delete pCParser;
		bRet = false;
	}

	gsCmdFile.Format("%sDesignCmds.dat", m_gsAreaListFile.AbsolutePath());
	CCmdParser* pDParser = new CCmdParser;

	if (pDParser->Init(gsCmdFile))
	  m_CmdParsers.push_back( pDParser );
	else
	{
		delete pDParser;
		bRet = false;
	}

	gsCmdFile.Format("%sCommands.dat", m_gsAreaListFile.AbsolutePath());

	if (pParser->Init(gsCmdFile))
	  m_CmdParsers.push_back( pParser );
	else
	{
		delete pParser;
		bRet = false;
	}

	if ( !bRet )
		g_Log.Log(LOG_ERROR, "Unable to load commands.");
	else
	{
		int nCommands = 0;
		CmdParsers::iterator pos;
		
		for (pos=m_CmdParsers.begin(); pos != m_CmdParsers.end(); pos++)
			nCommands += (*pos)->m_Commands.size();

		g_Log.Log(LOG_INFO, "Loaded %d Commands.", nCommands);
	}

	return bRet;
}


bool CGameWorld::LoadEmotions()
{
	LOG_SCOPE("CGameWorld::LoadEmotions");
	gFileName gsEmoteFile;
	CEmoteParser* pEmoteParser = new CEmoteParser;
	bool bCom = true;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading Emotions...");
	// Format the filename
	gsEmoteFile.Format("%sEmotions.dat", m_gsAreaListFile.AbsolutePath());

	// Read in the Emotions
	if (pEmoteParser->Load(gsEmoteFile))
	{
		m_EmoParsers.push_back(pEmoteParser);		
	}
	else
	{
		bCom = false;
		delete pEmoteParser;
	}

	if (!bCom)
	{
		g_Log.Log(LOG_ERROR, "Unable to load emotions.");
	}
	else
	{
		int nEmotes = 0;
		EmoParsers::iterator pos;
		for (pos=m_EmoParsers.begin(); pos != m_EmoParsers.end(); pos++)
			nEmotes += (*pos)->m_Emotions.size();

		g_Log.Log(LOG_INFO, "Loaded %d Emotions.", nEmotes);

	}


	return bCom;

}

bool CGameWorld::LoadRaces()
{
	LOG_SCOPE("CGameWorld::LoadRaces");
	bool bCom = true;
	gFileName gsRaceList;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading Races...");
	// Format the filename
	gsRaceList.Format("%sracelist.dat", m_gsAreaListFile.AbsolutePath());

	// Read in the Emotions
	if (!m_Races.Load(gsRaceList))
	{
		bCom = false;
		g_Log.Log(LOG_ERROR, "Unable to load races.");
	}
	else
	{
		g_Log.Log(LOG_INFO, "Loaded %d Races.", m_Races.Races().size());
	}

	return bCom;
}

bool CGameWorld::LoadEpacs()
{
	LOG_SCOPE("CGameWorld::LoadEpacs");
	bool bCom = true;
	CEpacs *pEpacs = new CEpacs;
	gFileName gsEpacs;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading epacs skills and configuration...");
	// Format the filename
	gsEpacs.Format("%sepacs.dat", m_gsAreaListFile.AbsolutePath());

	// Read in the Emotions
	if (!pEpacs->Load(gsEpacs))
	{
		bCom = false;
		g_Log.Log(LOG_ERROR, "Unable to load epacs.");
	}
	else
	{
		m_Epacs = *pEpacs;
		g_Log.Log(LOG_INFO, "Loaded %d Skills.", m_Epacs.Skills().size());
		g_Log.Log(LOG_INFO, "Loaded epacs configuration");
	}

	return bCom;
}
	
bool CGameWorld::LoadSpace()
{
	LOG_SCOPE("CGameWorld::LoadSpace");
	gFileName gsSpaceFile;
	bool bCom = false;
	CGameObjects& globals = CGameObjects::Get();
	CGalaxy* pGalaxy = new CGalaxy;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading Space...");

	// Format the filename
	gsSpaceFile.Format("%sGalaxy.dat", globals.m_Config.szDir[CGameObjects::_SPACEDIR]);

	if (pGalaxy->Load(gsSpaceFile))
	{
		m_Galaxy = *pGalaxy; // Assign Galaxy object
		bCom = true;
	}


	if (!bCom)
	{
		g_Log.Log(LOG_ERROR, "Unable to load space.");
	}
	else
	{
		g_Log.Log(LOG_INFO, "Loaded %d Sectors.", m_Galaxy.m_SectorList.size());
		g_Log.Log(LOG_INFO, "Loaded %d Spatial Objects.", m_Galaxy.m_gSpatialMap.size());

		int nCount = 0;
		for (SpatialMap::iterator spa = m_Galaxy.m_SpatialMap.begin(); spa != m_Galaxy.m_SpatialMap.end(); spa++)
			nCount += (*spa).second.size();

		g_Log.Log(LOG_INFO, "Loaded %d Spatial Objects into space.", nCount);
		g_Log.Log(LOG_INFO, "Loaded %d Ships.", m_Galaxy.m_ShipList.size());
	}


	return bCom;

}

bool CGameWorld::LoadModules()
{
	LOG_SCOPE("CGameWorld::LoadModules");
	gFileName gsCompFile, gsModFile;
	bool bCom = false;
	CGameObjects& globals = CGameObjects::Get();
	CMLoader* pMLoader = new CMLoader;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading Modules...");

	// Format the filename
	gsModFile.Format("%sShips\\Modules\\Modules.dat", globals.m_Config.szDir[CGameObjects::_SPACEDIR]);

	if (pMLoader->Load(gsModFile))
	{
		m_MLoader = *pMLoader;
		bCom = true;
	}

	if (!bCom)
	{
		g_Log.Log(LOG_ERROR, "Unable to load Modules.");
	}

	return bCom;

}

bool CGameWorld::LoadTemplates()
{
	LOG_SCOPE("CGameWorld::LoadTemplates");

	gFileName gsTempFile;
	bool bCom = false;
	CGameObjects& globals = CGameObjects::Get();
	CTLoader* pLoader = new CTLoader;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading Templates...");

	// Format the filename
	gsTempFile.Format("%sShips\\Templates\\Templates.dat", globals.m_Config.szDir[CGameObjects::_SPACEDIR]);

	if (pLoader->Load(gsTempFile))
	{
		m_TLoader = *pLoader;
		bCom = true;
	}


	if (!bCom)
	{
		g_Log.Log(LOG_ERROR, "Unable to load design template.");
	}
	else
	{
		g_Log.Log(LOG_INFO, "Loaded %d Design Templates.", m_TLoader.m_Templates.size());
	}

	return bCom;

}

bool CGameWorld::LoadCrews()
{
	LOG_SCOPE("CGameWorld::LoadCrews");
	gFileName gsTempFile;
	bool bCom = false;
	CGameObjects& globals = CGameObjects::Get();
	CCLoader* pLoader = new CCLoader;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading Crews...");

	// Format the filename
	gsTempFile.Format("%sCrews\\Crews.dat", globals.m_Config.szDir[CGameObjects::_SPACEDIR]);

	if (pLoader->Load(gsTempFile))
	{
		m_CLoader = *pLoader;
		bCom = true;
	}


	if (!bCom)
	{
		g_Log.Log(LOG_ERROR, "Unable to load ship crews.");
	}
	else
	{
		g_Log.Log(LOG_INFO, "Loaded %d Ship Crews.", m_CLoader.m_Crews.size());
	}

	return bCom;

}

bool CGameWorld::LoadHullCubes()
{
	LOG_SCOPE("CGameWorld::LoadHullCubes");
	gFileName gsHullFile;
	bool bCom = false;
	CGameObjects& globals = CGameObjects::Get();
	CHLoader* pHLoader = new CHLoader;
	
	// Report Loading
	g_Log.Log(LOG_INFO, "Loading HullCubes...");

	// Format the filename
	gsHullFile.Format("%sShips\\HullCubes\\HullCubes.dat", globals.m_Config.szDir[CGameObjects::_SPACEDIR]);

	if (pHLoader->Load(gsHullFile))
	{
		m_HLoader = *pHLoader;
		bCom = true;
	}

	if (!bCom)
	{
		g_Log.Log(LOG_ERROR, "Unable to load HullCubes.");
	}

	return bCom;

}


bool CGameWorld::LoadAreas()
{
	LOG_SCOPE("CGameWorld::LoadAreas");
	std::fstream	fpAreaList;
	std::fstream	fpArea;
	gFileName	gsDir;
	gFileName	szName;
	CArea* pArea = NULL;
	CNpc  *pNpc = NULL;

	g_Log.Log(LOG_INFO, "Loading Areas...");

	szName = m_gsAreaListFile;
	gsDir = szName.AbsolutePath();

	// First, load the area listing.
	fpAreaList.open(szName, ios::in|ios::nocreate);

	if ( fpAreaList.is_open() )
	{ // Ok, got the area list file opened, now scan through and load each area in the list.
		gString szArea;

		while ( !fpAreaList.eof() && !fpAreaList.fail() )
		{
			szArea = CGameObjects::Get().Tools()->ReadLn(fpAreaList);
			szArea.TrimSpacesRight();

			if ( !szArea.IsEmpty() && szArea[0] != EOF && szArea.Find("//") != 0 ) // not commented
			{
				CArea* pArea = new CArea();

				pArea->m_pHomeWorld = this;

				pArea->m_gsFileName.Format("%sAreas\\%s", gsDir, szArea);

				if (pArea->Load())
					m_Areas.push_back(pArea);
				else
					delete pArea;
			}
		}

		fpAreaList.close();

		Navigator()->Init();

		g_Log.Log(LOG_INFO, "Loaded %d Areas.", m_Areas.size());
		return true;
	}
	else
		g_Log.Log(LOG_ERROR, "Unable to open area list \"%s\".", m_gsAreaListFile);

	return false;
}

bool CGameWorld::Interpret(CActor* pA, gString CommandLine)
{
	CmdParsers::iterator pos;
	EmoParsers::iterator emo;
	CCmdParser* pParser = NULL;
	CEmoteParser* pEmoteParser = NULL;
	bool bHandled = false;

	if ( CommandLine.IsEmpty() || CommandLine == " " )
		return false;


	if (pA && pA->ActorStates()->IsSet(CActor::_FROZEN))
	{
		if (pA->ActorFlags()->IsSet(CActor::_ADMINISTRATOR))
		{
			pA->Write("Engaging admin auto-defrost.\n\rDefrost complete.\n\r");
			pA->ActorStates()->RemoveBit(CActor::_FROZEN);
			return true;
		}

		pA->Write("Not looking likely! You're still totally frozen!\n\r");
		return true;
	}



	// Check if its a Command
	for (pos = m_CmdParsers.begin(); pos != m_CmdParsers.end(); pos++)
	{
		pParser = (*pos);

		if (pParser->IsActive() && pParser->CanAccess(pA))
		{
			// [1] Design command
			if (pParser->m_gsName == "Design Commands")
			{
				// Check if our Actor is working on a Template
				CPlayer* pPlayer = (CPlayer*) pA;
				if (pPlayer->m_Template)
				{
					if ((*pos)->Interpret(pA, CommandLine))
					{
						bHandled = true;
						// Output a Design Prompt so they know where they are
						if (CommandLine != "list " && CommandLine != "show " && CommandLine != "stop")
							pPlayer->Write("\n\r%s #200|#700 %s #200|#700 %s\n\r", pPlayer->m_Frame ? pPlayer->m_Frame->m_gsName : "#200<#701none#200>#700", pPlayer->m_HullCube ? pPlayer->m_HullCube->m_gsName : "#200<#701none#200>#700", pPlayer->m_Component ? pPlayer->m_Component->m_gsName : "#200<#701none#200>#700");
					}

				}
				else
				{
					// If the player isn't working on a Template there is no reason to try
					// and get the Design Interpreter to look at it.
					continue;
				}
			}
			// [2] Crew Command
			else if (pParser->m_gsName == "Crew Commands")
			{
				if (pA->Command())
				{
					// Power and Comm are a Special case when suppled with no argument
					if (CommandLine != "power" && CommandLine != "comm" && CommandLine != "comm recordings")
						bHandled = (*pos)->Interpret(pA, CommandLine);
					else
						continue;
				}
				else
				{
					// Like the Design Interpreter above, we only check if this command is a crew one
					// if the player is actually Commanding a vessel
					continue;
				}

			}
		
			// [3] Normal Commands
			if (!bHandled)
			{
				bHandled = (*pos)->Interpret(pA, CommandLine);
			}
		}
	}

	// If not, is it an Emotion?
	if (!bHandled)
	{
		for (emo = m_EmoParsers.begin(); emo != m_EmoParsers.end(); emo++)
		{
			pEmoteParser = (*emo);

			if (pEmoteParser->Interpret(pA, CommandLine))
			{
				bHandled = true;
			}	
		}
	}

	
	if ( !bHandled )
		pA->Write("I dont understand what you mean by \"%s\"\n\r", CommandLine);

	// Bust a prompt!
	gString gsPrompt = pA->IsPlayer() ? ((CPlayer*)pA)->Prompt() : " $]";
			pA->Write( "\n\r%s> ", gsPrompt );

	return bHandled;
}